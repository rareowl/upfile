<!DOCTYPE html>
<html lang="en" data-theme="<%= theme %>">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>upfile.1 - File Sharing</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <a href="/" class="logo">upfile.1</a>
    <div class="auth-links">
        <% if (session.userId) { %>
            <a href="/profile">profile</a> | <a href="/logout">logout</a>
        <% } else { %>
            <a href="/register">register</a> | <a href="/login">login</a>
        <% } %>
    </div>
    <div class="container">
        <div class="upload-form">
            <input type="file" id="fileInput" name="file" required>
            <button id="uploadButton" onclick="uploadFile()">upload</button>
        </div>

        <!-- Progress bar container -->
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">0%</div>
        </div>

        <!-- Result message and success container -->
        <div class="result-message">
            <!-- Error messages will go here -->
            <div id="resultMessage"></div>
            <!-- Success message with link -->
            <div id="uploadSuccess" style="display: none;">
                <p>file uploaded successfully</p>
                <div class="link-container">
                    <a id="downloadLink" href="" target="_blank"></a>
                    <button id="copyButton" onclick="copyLink()">
                        copy
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Encryption helper functions
        async function generateKey() {
            return await window.crypto.subtle.generateKey(
                {
                    name: "AES-GCM",
                    length: 256
                },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function exportKey(key) {
            const exported = await window.crypto.subtle.exportKey("raw", key);
            return Array.from(new Uint8Array(exported))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        async function importKey(keyHex) {
            const keyData = new Uint8Array(keyHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
            return await window.crypto.subtle.importKey(
                "raw",
                keyData,
                "AES-GCM",
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptFile(file) {
            const key = await generateKey();
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const arrayBuffer = await file.arrayBuffer();

            const encryptedContent = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                arrayBuffer
            );

            const encryptedFile = new File(
                [encryptedContent],
                file.name,
                { type: file.type }
            );

            const keyHex = await exportKey(key);
            const ivHex = Array.from(iv)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');

            return {
                file: encryptedFile,
                key: keyHex,
                iv: ivHex
            };
        }

        // Keep your existing variable declarations
        const fileInput = document.getElementById('fileInput');
        const uploadButton = document.getElementById('uploadButton');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const resultMessage = document.getElementById('resultMessage');
        const uploadSuccess = document.getElementById('uploadSuccess');
        const downloadLink = document.getElementById('downloadLink');

        // Add this new function
        async function getMaxFileSize() {
            try {
                const response = await fetch('/get-max-file-size');
                const data = await response.json();
                return data.maxSize;
            } catch (error) {
                console.error('Error getting max file size:', error);
                return null;
            }
        }

        // Updated uploadFile function with encryption
        async function uploadFile() {
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a file first!');
                return;
            }

            // Check file size
            const maxSize = await getMaxFileSize();
            if (maxSize && file.size > maxSize) {
                const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(2);
                resultMessage.textContent = `File size exceeds the limit of ${maxSizeMB} MB`;
                return;
            }

            progressContainer.style.display = 'block';
            uploadButton.disabled = true;
            uploadSuccess.style.display = 'none';
            resultMessage.textContent = '';

            try {
                // Encrypt the file before upload
                const { file: encryptedFile, key, iv } = await encryptFile(file);
                const formData = new FormData();
                formData.append('file', encryptedFile);
                formData.append('originalName', file.name);

                const xhr = new XMLHttpRequest();
                xhr.open('POST', '/upload', true);

                xhr.upload.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percent = (event.loaded / event.total) * 100;
                        progressBar.style.width = percent + '%';
                        progressText.textContent = Math.round(percent) + '%';
                    }
                };

                xhr.onload = () => {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        
                        if (xhr.status === 200 && response.success) {
                            // Hide progress bar
                            progressContainer.style.display = 'none';
                            
                            // Add encryption key and IV to download URL
                            const fullUrl = `${window.location.origin}${response.downloadLink}#key=${key}&iv=${iv}`;
                            downloadLink.href = fullUrl;
                            downloadLink.textContent = fullUrl;
                            uploadSuccess.style.display = 'block';
                            resultMessage.textContent = '';
                        } else {
                            // Show error message
                            progressContainer.style.display = 'none';
                            uploadSuccess.style.display = 'none';
                            resultMessage.textContent = response.message || 'Upload failed. Please try again.';
                        }
                    } catch (e) {
                        // Handle parsing error
                        progressContainer.style.display = 'none';
                        uploadSuccess.style.display = 'none';
                        resultMessage.textContent = 'Upload failed. Please try again.';
                    }
                    
                    // Re-enable upload button
                    uploadButton.disabled = false;
                };

                xhr.onerror = () => {
                    progressContainer.style.display = 'none';
                    uploadSuccess.style.display = 'none';
                    resultMessage.textContent = 'Upload failed. Please check your connection.';
                    uploadButton.disabled = false;
                };

                xhr.send(formData);
            } catch (error) {
                console.error('Encryption error:', error);
                progressContainer.style.display = 'none';
                uploadSuccess.style.display = 'none';
                resultMessage.textContent = 'Error encrypting file. Please try again.';
                uploadButton.disabled = false;
            }
        }

        // Keep your existing copyLink function
        function copyLink() {
            const linkText = downloadLink.href;
            navigator.clipboard.writeText(linkText).then(() => {
                const copyButton = document.getElementById('copyButton');
                copyButton.textContent = 'copied!';
                setTimeout(() => {
                    copyButton.textContent = 'copy';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy link: ', err);
            });
        }

        fileInput.addEventListener('change', () => {
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
            uploadSuccess.style.display = 'none';
            resultMessage.textContent = ''; // Clear any error messages
            uploadButton.disabled = false;
        });
    </script>
    <div class="footer">
        <a href="/about">about us</a>
    </div>
</body>
</html>