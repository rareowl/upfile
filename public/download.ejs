<!DOCTYPE html>
<html lang="en" data-theme="<%= theme %>">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Download - upfile.1</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <a href="/" class="logo">upfile.1</a>
    
    <div class="container">
        <div class="download-info">
            <div class="info-row">
                <span class="label">file:</span>
                <span class="value"><%= fileName %></span>
            </div>
            <div class="info-row">
                <span class="label">size:</span>
                <span class="value"><%= fileSize %></span>
            </div>
            <% if (encrypted) { %>
            <div class="info-row">
                <span class="label">status:</span>
                <span class="value">encrypted</span>
            </div>
            <% } %>
        </div>
        <button onclick="startDownload()" class="download-button" id="downloadButton">download</button>

        <!-- Progress container -->
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">0%</div>
            <div class="progress-detail" id="progressDetail"></div>
        </div>
    </div>

    <script>
        // Utility function to format bytes
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // Progress UI elements
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressDetail = document.getElementById('progressDetail');
        const downloadButton = document.getElementById('downloadButton');

        // Update progress UI
        function updateProgress(percent, detail) {
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `${Math.round(percent)}%`;
            if (detail) progressDetail.textContent = detail;
        }

        async function importKey(keyHex) {
            try {
                const keyData = new Uint8Array(keyHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
                return await window.crypto.subtle.importKey(
                    "raw",
                    keyData,
                    "AES-GCM",
                    true,
                    ["decrypt"]
                );
            } catch (error) {
                console.error('Error importing key:', error);
                throw new Error('Failed to import decryption key');
            }
        }

        async function decryptData(encryptedData, key, iv) {
            try {
                updateProgress(60, 'Decrypting file...');
                
                const decryptedContent = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    key,
                    encryptedData
                );

                updateProgress(90, 'Decryption complete');
                return new Blob([decryptedContent]);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Failed to decrypt file');
            }
        }

        async function decryptFile(encryptedBlob, keyHex, ivHex) {
    try {
        updateProgress(55, 'Preparing for decryption...');
        
        // Import the key
        const keyData = new Uint8Array(keyHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
        const key = await window.crypto.subtle.importKey(
            "raw",
            keyData,
            "AES-GCM",
            true,
            ["decrypt"]
        );
        
        // Prepare IV
        const iv = new Uint8Array(ivHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
        
        updateProgress(60, 'Reading encrypted file...');
        
        // Convert blob to ArrayBuffer
        const encryptedBuffer = await encryptedBlob.arrayBuffer();
        
        updateProgress(70, `Decrypting ${formatBytes(encryptedBuffer.byteLength)}...`);
        
        // Decrypt the entire file at once
        const decryptedContent = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: iv
            },
            key,
            encryptedBuffer
        );
        
        updateProgress(90, 'Decryption complete!');
        
        // Create a blob from the decrypted content
        return new Blob([decryptedContent]);
    } catch (error) {
        console.error('Decryption error:', error);
        throw new Error('Failed to decrypt file: ' + error.message);
    }
}


        async function startDownload() {
    try {
        downloadButton.disabled = true;
        progressContainer.style.display = 'block';
        updateProgress(0, 'Checking download status...');

        const response = await fetch('/check-download-status');
        if (!response.ok) {
            throw new Error('Failed to check download status');
        }
        const data = await response.json();
        
        if (data.willBeThrottled) {
            alert('You have exceeded your download limit. Download speed will be throttled.');
        }

        updateProgress(10, 'Starting download...');

        // Download file
        const downloadResponse = await fetch(window.location.pathname + '/download');
        if (!downloadResponse.ok) {
            throw new Error(`Download failed with status: ${downloadResponse.status}`);
        }

        const contentLength = downloadResponse.headers.get('Content-Length');
        const isEncrypted = downloadResponse.headers.get('X-File-Encrypted') === 'true';
        
        // Read the response as a blob
        updateProgress(20, 'Reading response...');
        const blob = await downloadResponse.blob();
        updateProgress(50, 'Download complete. Processing...');

        if (isEncrypted) {
            // Get decryption parameters from URL fragment
            const fragment = window.location.hash.substring(1);
            const params = new URLSearchParams(fragment);
            const keyHex = params.get('key');
            const ivHex = params.get('iv');

            if (!keyHex || !ivHex) {
                throw new Error('Missing decryption keys. The download link may be incomplete.');
            }

            try {
                // Decrypt the file
                const decryptedBlob = await decryptFile(blob, keyHex, ivHex);
                
                // Trigger download
                updateProgress(95, 'Preparing final download...');
                const url = window.URL.createObjectURL(decryptedBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '<%= fileName %>';
                document.body.appendChild(a);
                
                updateProgress(100, 'Starting file download...');
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    progressContainer.style.display = 'none';
                    downloadButton.disabled = false;
                }, 1000);
            } catch (error) {
                throw new Error('Decryption failed: ' + error.message);
            }
        } else {
            // Handle unencrypted file
            updateProgress(90, 'Preparing download...');
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '<%= fileName %>';
            document.body.appendChild(a);
            
            updateProgress(100, 'Starting file download...');
            a.click();
            
            // Cleanup
            setTimeout(() => {
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                progressContainer.style.display = 'none';
                downloadButton.disabled = false;
            }, 1000);
        }
    } catch (error) {
        console.error('Download error:', error);
        progressDetail.textContent = 'Error: ' + error.message;
        progressContainer.style.display = 'none';
        downloadButton.disabled = false;
        alert('Download failed: ' + error.message);
    }
}
    </script>

    <style>
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .progress {
            width: 100%;
            height: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--text-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .progress-detail {
            text-align: center;
            font-size: 0.8rem;
            color: #666;
        }

        .download-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>

    <div class="footer">
        <a href="/about">about us</a>
    </div>
</body>
</html>